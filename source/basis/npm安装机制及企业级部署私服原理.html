<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/qiaolingyan/blog-img@master/vuepress/logo.4rs1px4f8j60.jpg"><title>npm 安装机制及企业级部署私服原理 | qiao</title><meta name="description" content="happy day"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.19">
    <link rel="preload" href="/assets/js/runtime~app.89d2221a.js" as="script"><link rel="preload" href="/assets/css/styles.55340b42.css" as="style"><link rel="preload" href="/assets/js/640.35c7ecf5.js" as="script"><link rel="preload" href="/assets/js/app.983a575d.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.55340b42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="https://cdn.jsdelivr.net/gh/qiaolingyan/blog-img@master/vuepress/logo.4rs1px4f8j60.jpg" alt="qiao"><span class="site-name can-hide">qiao</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="指南"><span class="title">指南</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="指南"><span class="title">指南</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/guide/js/" class="nav-link" aria-label="Js"><!--[--><!--]--> Js <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/webpack/" class="nav-link" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/vue/" class="nav-link" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/react/" class="nav-link" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/SSR/" class="nav-link" aria-label="SSR"><!--[--><!--]--> SSR <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/nodejs/" class="nav-link" aria-label="NodeJs"><!--[--><!--]--> NodeJs <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/algorithm/" class="nav-link" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/CICD/" class="nav-link" aria-label="自动化部署"><!--[--><!--]--> 自动化部署 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/other/" class="nav-link" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><a href="/interview/" class="nav-link" aria-label="面试"><!--[--><!--]--> 面试 <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分类"><span class="title">分类</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="分类"><span class="title">分类</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/source/basis/" class="nav-link router-link-active" aria-label="前端基础建设与架构"><!--[--><!--]--> 前端基础建设与架构 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><a href="/link/" class="nav-link" aria-label="Link"><!--[--><!--]--> Link <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="指南"><span class="title">指南</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="指南"><span class="title">指南</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/guide/js/" class="nav-link" aria-label="Js"><!--[--><!--]--> Js <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/webpack/" class="nav-link" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/vue/" class="nav-link" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/react/" class="nav-link" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/SSR/" class="nav-link" aria-label="SSR"><!--[--><!--]--> SSR <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/nodejs/" class="nav-link" aria-label="NodeJs"><!--[--><!--]--> NodeJs <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/algorithm/" class="nav-link" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/CICD/" class="nav-link" aria-label="自动化部署"><!--[--><!--]--> 自动化部署 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/other/" class="nav-link" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><a href="/interview/" class="nav-link" aria-label="面试"><!--[--><!--]--> 面试 <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分类"><span class="title">分类</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="分类"><span class="title">分类</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/source/basis/" class="nav-link router-link-active" aria-label="前端基础建设与架构"><!--[--><!--]--> 前端基础建设与架构 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><a href="/link/" class="nav-link" aria-label="Link"><!--[--><!--]--> Link <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><section class="sidebar-group"><p class="sidebar-heading active">前端基础建设与架构</p><ul class=""><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-link active" aria-label="npm 安装机制及企业级部署私服原理"><!--[--><!--]--> npm 安装机制及企业级部署私服原理 <!--[--><!--]--></a><ul class="sidebar-sub-headers"><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_1-npm-内部机制和核心原理" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="1. npm 内部机制和核心原理"><!--[--><!--]--> 1. npm 内部机制和核心原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_2-npm-的安装机制和背后思想" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="2. npm 的安装机制和背后思想"><!--[--><!--]--> 2. npm 的安装机制和背后思想 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_3-npm-缓存机制" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="3. npm 缓存机制"><!--[--><!--]--> 3. npm 缓存机制 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-npm-不完全指南" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4. npm 不完全指南"><!--[--><!--]--> 4. npm 不完全指南 <!--[--><!--]--></a><ul class="sidebar-sub-headers"><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-1-自定义-npm-init" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4.1 自定义 npm init"><!--[--><!--]--> 4.1 自定义 npm init <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-2-利用-npm-link-高效率在本地调试以验证包的可用性" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4.2 利用 npm link，高效率在本地调试以验证包的可用性"><!--[--><!--]--> 4.2 利用 npm link，高效率在本地调试以验证包的可用性 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-3-npx-的作用" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4.3 npx 的作用"><!--[--><!--]--> 4.3 npx 的作用 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-4-npm-多源镜像和企业级部署私服原理" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4.4 npm 多源镜像和企业级部署私服原理"><!--[--><!--]--> 4.4 npm 多源镜像和企业级部署私服原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-5-npm-配置作用优先级" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4.5 npm 配置作用优先级"><!--[--><!--]--> 4.5 npm 配置作用优先级 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_4-6-npm-镜像和安装问题" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="4.6 npm 镜像和安装问题"><!--[--><!--]--> 4.6 npm 镜像和安装问题 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/source/basis/npm%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%83%A8%E7%BD%B2%E7%A7%81%E6%9C%8D%E5%8E%9F%E7%90%86.html#_5-结语" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="5. 结语"><!--[--><!--]--> 5. 结语 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/source/basis/Yarn%20%E7%9A%84%E5%AE%89%E8%A3%85%E7%90%86%E5%BF%B5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%9B%B0%E5%A2%83.html" class="nav-link sidebar-link" aria-label="Yarn 的安装理念及如何破解依赖管理困境"><!--[--><!--]--> Yarn 的安装理念及如何破解依赖管理困境 <!--[--><!--]--></a><!----><!--]--></li></ul></section><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>前端工程化离不开 npm（node package manager） 或者 Yarn 这些管理工具。npm 或 Yarn 在工程项目中，除了负责依赖的安装和维护以外，还能通过 npm scripts 串联起各个职能部分，让独立的环节自动运转起来。</p><p>无论是 npm 还是 Yarn，它们的体系都非常庞大，在使用过程中你很可能产生如下疑问：</p><ul><li><p>项目依赖出现问题时，删除大法好，即删除 node_modules 和 lockfiles，再重新 install，这样操作是否存在风险？</p></li><li><p>把所有依赖都安装到 dependencies 中，不区分 devDependencies 会有问题吗？</p></li><li><p>我们的应用依赖了公共库 A 和公共库 B，同时公共库 A 也依赖了公共库 B，那么公共库 B 会被多次安装或重复打包吗？</p></li><li><p>一个项目中，既有人用 npm，也有人用 Yarn，这会引发什么问题？</p></li><li><p>我们是否应该提交 lockfiles 文件到项目仓库呢？</p></li></ul><p>接下来的 01 ~ 03 讲我们就进一步聊一聊这些问题！</p><h2 id="_1-npm-内部机制和核心原理"><a class="header-anchor" href="#_1-npm-内部机制和核心原理">#</a> 1. npm 内部机制和核心原理</h2><p>我们先来看看 npm 的核心目标：</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Bring the best of open source to you, your team and your company. 给你和你的团队、你的公司带来最好的开源库和依赖。</p></div><p>通过这句话，我们可以知道 npm 最重要的一环是安装和维护依赖。在平时开发中，**“删除 node_modules，重新 npm install”**是一个百试不爽的解决 npm 安装类问题的方法。但是其中的作用原理是什么？这样的操作是否规范呢？</p><p>这一讲，我们就先从 npm 内部机制出发来剖析此类问题。了解完安装机制和原理，我相信你对于工程中依赖的问题，将有一个更加体系化的认知。</p><h2 id="_2-npm-的安装机制和背后思想"><a class="header-anchor" href="#_2-npm-的安装机制和背后思想">#</a> 2. npm 的安装机制和背后思想</h2><p>npm 的安装机制非常值得探究。Ruby 的 Gem、Python 的 pip 都是全局安装，但是 npm 的安装机制秉承了不同的设计哲学。</p><p>它会优先安装依赖包到当前项目目录，使得不同应用项目的依赖各成体系，同时还减轻了包作者的 API 兼容性压力，<strong>但这样做的缺陷也很明显</strong>：如果我们的项目 A 和项目 B，都依赖了相同的公共库 C，那么公共库 C 一般都会在项目 A 和项目 B 中，各被安装一次。这就说明，<strong>同一个依赖包可能在我们的电脑上进行多次安装</strong>。</p><p>当然，对于一些工具模块比如 supervisor 和 gulp，你仍然可以使用全局安装模式，这样方便注册 path 环境变量，我们可以在任何地方直接使用 supervisor、 gulp 这些命令。（不过，一般还是建议不同项目维护自己局部的 gulp 开发工具以适配不同项目需求。）</p><p>下面，言归正传，我们通过流程图来分析 npm install 的安装机制。</p><p><img src="/assets/img/Cip5yF_axkqAclTFAAJmlxGYSmI551.efb63b6a.png" alt="img"></p><p>npm install 执行之后，首先，检查并获取 npm 配置，<strong>这里的优先级为：项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件&gt; 全局级的 .npmrc 文件 &gt; npm 内置的 .npmrc 文件</strong>。</p><p>然后检查项目中是否有 package-lock.json 文件。</p><p>如果有，则检查 package-lock.json 和 package.json 中声明的依赖是否一致：</p><ul><li><p>一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖；</p></li><li><p>不一致，按照 npm 版本进行处理（不同 npm 版本处理会有不同，具体处理方式如图所示）。</p></li></ul><p>如果没有，则根据 package.json 递归构建依赖树。然后按照构建好的依赖树下载完整的依赖资源，在下载时就会检查是否存在相关资源缓存：</p><ul><li><p>存在，则将缓存内容解压到 node_modules 中；</p></li><li><p>否则就先从 npm 远程仓库下载包，校验包的完整性，并添加到缓存，同时解压到 node_modules。</p></li></ul><p>最后生成 package-lock.json。</p><p>构建依赖树时，当前依赖项目不管其是直接依赖还是子依赖的依赖，都应该按照扁平化原则，优先将其放置在 node_modules 根目录（最新版本 npm 规范）。在这个过程中，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块（最新版本 npm 规范）。</p><p>我给出的流程图中有标注更细节的内容，这里就不再赘述了。<strong>你要格外注意图中标明的 npm 不同版本的不同处理情况，并学会从这种“历史问题”中总结 npm 使用的团队最佳实践：同一个项目团队，应该保证 npm 版本的一致</strong>。</p><p>前端工程中，依赖嵌套依赖，一个中型项目中 node_moduels 安装包可能就已经是海量的了。如果安装包每次都通过网络下载获取，无疑会增加安装时间成本。对于这个问题，缓存始终是一个好的解决思路，我们接下来看看 npm 自己的缓存机制。</p><h2 id="_3-npm-缓存机制"><a class="header-anchor" href="#_3-npm-缓存机制">#</a> 3. npm 缓存机制</h2><p>对于一个依赖包的同一版本进行本地化缓存，是当代依赖包管理工具的一个常见设计。使用时要先执行以下命令：</p><p>复制代码</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">npm</span> config get cache
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>得到配置缓存的根目录在 /Users/cehou/.npm（ Mac OS 中，npm 默认的缓存位置） 当中。我们 cd 进入 /Users/cehou/.npm 中可以发现<code>_cacache</code>文件。事实上，在 npm v5 版本之后，缓存数据均放在根目录中的<code>_cacache</code>文件夹中。</p><p><img src="/assets/img/CgqCHl_TbUSAZ8CsAAF3O01IL9Q887.4b4f0513.png" alt="img"></p><p>我们可以使用以下命令清除 /Users/cehou/.npm/_cacache 中的文件：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code> <span class="token function">npm</span> cache clean --force
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>你可以点击<a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm/" target="_blank" rel="noopener noreferrer">这里<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>看看其中对应的 npm 源码。</p><p>接下来打开<code>_cacache</code>文件，看看 npm 缓存了哪些东西，一共有 3 个目录：</p><ul><li><p>content-v2</p></li><li><p>index-v5</p></li><li><p>tmp</p></li></ul><p>其中 content-v2 里面基本都是一些二进制文件。为了使这些二进制文件可读，我们把二进制文件的扩展名改为 .tgz，然后进行解压，得到的结果其实就是我们的 npm 包资源。</p><p>而 index-v5 文件中，我们采用跟刚刚一样的操作就可以获得一些描述性的文件，事实上这些内容就是 content-v2 里文件的索引。</p><p>这些缓存如何被储存并被利用的呢？</p><p>这就和 npm install 机制联系在了一起。当 npm install 执行时，通过<a href="https://www.npmjs.com/package/pacote" target="_blank" rel="noopener noreferrer">pacote<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>把相应的包解压在对应的 node_modules 下面。npm 在下载依赖时，先下载到缓存当中，再解压到项目 node_modules 下。pacote 依赖<a href="https://github.com/npm/npm-registry-fetch#npm-registry-fetch" target="_blank" rel="noopener noreferrer">npm-registry-fetch<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>来下载包，npm-registry-fetch 可以通过设置 cache 属性，在给定的路径下根据<a href="https://datatracker.ietf.org/doc/rfc7234/" target="_blank" rel="noopener noreferrer">IETF RFC 7234<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>生成缓存数据。</p><p>接着，在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，并再次通过<a href="https://www.npmjs.com/package/pacote" target="_blank" rel="noopener noreferrer">pacote<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>把对应的二进制文件解压到相应的项目 node_modules 下面，省去了网络下载资源的开销。</p><div class="custom-container tip"><p class="custom-container-title">注意</p><p>这里提到的缓存策略是从 npm v5 版本开始的。在 npm v5 版本之前，每个缓存的模块在 ~/.npm 文件夹中以模块名的形式直接存储，储存结构是：{cache}/{name}/{version}。</p></div><p>了解这些相对底层的内容可以直接帮助开发者排查 npm 相关问题，这也是区别一般程序员和架构师的细节之一。能不能在理论内容上多走一步，也决定了我们的技术能力能不能更上一层楼。这里我们进行了初步学习，我希望这也可以成为你探究底层的开始。</p><h2 id="_4-npm-不完全指南"><a class="header-anchor" href="#_4-npm-不完全指南">#</a> 4. npm 不完全指南</h2><p>接下来，我想介绍几个实用的 npm 小技巧，这些技巧并不包括“npm 快捷键”等常见内容，主要是从工程开发角度，聚焦更广泛的内容。这里我不会花大量篇幅讲解 npm 命令内容，这些知识你可以直接通过 <a href="https://docs.npmjs.com/cli/v7" target="_blank" rel="noopener noreferrer">npm cli <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>官方文档获得。</p><p>下面，我将从 npm 使用技巧以及一些常见使用误区来展开。</p><h3 id="_4-1-自定义-npm-init"><a class="header-anchor" href="#_4-1-自定义-npm-init">#</a> 4.1 自定义 npm init</h3><p>npm 支持我们自定义 npm init，快速创建一个符合自己需求的自定义项目。想象一下，<strong>npm init 命令本身并不复杂，它其实就是调用 shell 脚本输出一个初始化的 package.json 文件</strong>。那么相应地，我们要自定义 npm init 命令，就是写一个 node 脚本而已，它的 module.exports 即为 package.json 配置内容。</p><p>为了实现更加灵活的自定义功能，我们可以使用 prompt() 方法，获取用户输入并动态产生的内容：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> desc <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">&#39;请输入项目描述&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;项目描述...&#39;</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  key<span class="token operator">:</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">&#39;name?&#39;</span><span class="token punctuation">,</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#39;/&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  version<span class="token operator">:</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">&#39;version?&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;0.0.1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  description<span class="token operator">:</span> desc<span class="token punctuation">,</span>
  main<span class="token operator">:</span> <span class="token string">&#39;index.js&#39;</span><span class="token punctuation">,</span>
  repository<span class="token operator">:</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">&#39;github repository url&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&#39;touch README.md&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&#39;git init&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&#39;git add README.md&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&#39;git commit -m &quot;first commit&quot;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">git remote add origin </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">&#39;git push -u origin master&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> url<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>假设该脚本名为 .npm-init.js，我们执行下述命令来确保 npm init 所对应的脚本指向正确的文件：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init-module ~<span class="token punctuation">\</span>.npm-init.js
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>更多信息可见：<a href="https://docs.npmjs.com/cli/v7/commands/npm-init" target="_blank" rel="noopener noreferrer">npm-init<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。</p></div><p>我们也可以通过配置 npm init 默认字段来自定义 npm init 的内容：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.author.name <span class="token string">&quot;Lucas&quot;</span>
<span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.author.email <span class="token string">&quot;lucasXXXXXX@gmail.com&quot;</span>
<span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.author.url <span class="token string">&quot;lucasXXXXX.com&quot;</span>
<span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.license <span class="token string">&quot;MIT&quot;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>更多信息见：<a href="https://docs.npmjs.com/cli/v7/commands/npm-config/" target="_blank" rel="noopener noreferrer">npm-config<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。</p></div><h3 id="_4-2-利用-npm-link-高效率在本地调试以验证包的可用性"><a class="header-anchor" href="#_4-2-利用-npm-link-高效率在本地调试以验证包的可用性">#</a> 4.2 利用 npm link，高效率在本地调试以验证包的可用性</h3><p>当我们开发一个公共包时，总会有这样的困扰：假如我开发一个组件库，某个组件开发完成之后，如何验证该组件能在我的业务项目中正常运行呢？</p><p>除了写一个完备的测试以外，常见的思路就是<strong>在组件库开发中，设计 examples 目录或者一个 playground，启动一个开发服务，以验证组件的运行情况。</strong></p><p>然而真实应用场景是多种多样的，如果能在某个项目中率先尝试就太好了。但我们又不能发布一个不安全的包版本供业务项目使用。另一个“笨”方法是，手动复制粘贴组件并打包产出到业务项目的 node_modules 中进行验证，但是这种做法既不安全也会使得项目混乱，变得难以维护，同时过于依赖手工执行，这种操作非常原始。</p><p>那么如何<strong>高效率在本地调试以验证包的可用性</strong>呢？这个时候，我们就可以<strong>使用 npm link</strong>。简单来说，它可以<strong>将模块链接到对应的业务项目中运行</strong>。</p><p>我们来看一个具体场景，假设你正在开发项目 project 1，其中有个包 package 1，对应 npm 模块包名称是 npm-package-1，我们在 package 1 项目中加入了新功能 feature A，现在要验证在 project 1 项目中能否正常使用 package 1 的 feature A，你应该怎么做？</p><p>我们先在 package 1 目录中，执行 npm link，这样 npm link 通过链接目录和可执行文件，实现 npm 包命令的全局可执行。</p><p>然后在 project 1 中创建链接，执行 npm link npm-package-1 命令时，它就会去 /usr/local/lib/node_modules/ 这个路径下寻找是否有这个包，如果有就建立软链接。</p><p>这样一来，我们就可以在 project 1 的 node_module 中会看到链接过来的模块包 npm-package-1，此时的 npm-package-1 就带有最新开发的 feature A，这样一来就可以在 project 1 中正常开发调试 npm-package-1。当然别忘了，调试结束后可以执行 npm unlink 以取消关联。</p><p>从工作原理上总结，npm link 的本质就是软链接，它主要做了两件事：</p><ul><li><p>为目标 npm 模块（npm-package-1）创建软链接，将其链接到全局 node 模块安装路径 /usr/local/lib/node_modules/ 中；</p></li><li><p>为目标 npm 模块（npm-package-1）的可执行 bin 文件创建软链接，将其链接到全局 node 命令安装路径 /usr/local/bin/ 中。</p></li></ul><p>通过刚才的场景，你可以看到：<strong>npm link 能够在工程上解决依赖包在任何一个真实项目中进行调试的问题，并且操作起来更加方便快捷。</strong></p><h3 id="_4-3-npx-的作用"><a class="header-anchor" href="#_4-3-npx-的作用">#</a> 4.3 npx 的作用</h3><p>npx 由 npm v5.2 版本引入，解决了 npm 的一些使用快速开发、调试，以及项目内使用全局模块的痛点。</p><p><strong>在传统 npm 模式下</strong>，如果我们需要使用代码检测工具 <a href="https://eslint.bootcss.com/" target="_blank" rel="noopener noreferrer">ESLint<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>，就要先通过 npm install 安装：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> eslint --save-dev
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>然后在项目根目录下执行：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>./node_modules/.bin/eslint --init
./node_modules/.bin/eslint yourfile.js
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>或者通过项目脚本和 package.json 的 npm scripts 字段调用 ESLint。</p><p>而使用 npx 就简单多了，你只需要下面 2 个操作步骤：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>npx eslint --init
npx eslint yourfile.js
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为什么 npx 操作起来如此便捷呢？</p><p>这是因为它可以直接执行 node_modules/.bin 文件夹下的文件。在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script。</p><p><strong>npx 另一个更实用的好处是：npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题。</strong></p><p>运行如下命令后，npx 会将 create-react-app 下载到一个临时目录，使用以后再删除：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>npx create-react-app cra-project
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>更多关于 npx 的介绍你可以去<a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener noreferrer">官网<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>进一步查看。</p><p>现在，你已经对 npm 有了一个初步了解，我们接下来一同看看 npm 实操部分：多源镜像和企业级部署私服原理。</p><h3 id="_4-4-npm-多源镜像和企业级部署私服原理"><a class="header-anchor" href="#_4-4-npm-多源镜像和企业级部署私服原理">#</a> 4.4 npm 多源镜像和企业级部署私服原理</h3><p><strong>npm 中的源（registry），其实就是一个查询服务</strong>。以 npmjs.org 为例，它的查询服务网址是 https://registry.npmjs.org/。这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问 https://registry.npmjs.org/react，就会看到 react 模块所有版本的信息。</p><p>我们可以通过<code>npm config set</code>命令来设置安装源或者某个 scope 对应的安装源，很多企业也会搭建自己的 npm 源。我们常常会碰到需要使用多个安装源的项目，这时就可以通过 npm-preinstall 的钩子，通过 npm 脚本，在安装公共依赖前自动进行源切换：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;preinstall&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node ./bin/preinstall.js&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其中 preinstall.js 脚本内容，具体逻辑为通过 node.js 执行npm config set命令，代码如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>require<span class="token punctuation">(</span><span class="token string">&#39; child_process&#39;</span><span class="token punctuation">)</span>.exec<span class="token punctuation">(</span><span class="token string">&#39;npm config get registry&#39;</span>, function<span class="token punctuation">(</span>error, stdout, stderr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stdout.toString<span class="token punctuation">(</span><span class="token punctuation">)</span>.match<span class="token punctuation">(</span>/registry<span class="token punctuation">\</span>.x<span class="token punctuation">\</span>.com/<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    exec<span class="token punctuation">(</span><span class="token string">&#39;npm config set @xscope:registry https://xxx.com/npm/&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>国内很多开发者使用的 <a href="https://www.npmjs.com/package/nrm" target="_blank" rel="noopener noreferrer">nrm<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>（npm registry manager）是 npm 的镜像源管理工具，使用它可以快速地在 npm 源间切换，这当然也是一种选择。</p><p>你的公司是否也正在部署一个私有 npm 镜像呢？你有没有想过公司为什么要这样做呢？</p><p>虽然 npm 并没有被屏蔽，但是下载第三方依赖包的速度依然较缓慢，这严重影响 CI/CD 流程或本地开发效率。部署镜像后，一般可以<strong>确保高速、稳定的 npm 服务，而且使发布私有模块更加安全。除此之外，审核机制也可以保障私服上的 npm 模块质量和安全</strong>。</p><p>那么，如何部署一个私有 npm 镜像呢？</p><p>现在社区上主要有 3 种工具来搭建 npm 私服：nexus、verdaccio 以及 cnpm。</p><p>它们的工作原理相同，我们可以通过 nexus 的架构示例简单了解一下：</p><p><img src="/assets/img/CgqCHl_Tba6AcJj0AAGPl9HW2qg745.ad7ef97f.png" alt="img"></p><p>nexus 架构示例图</p><p>nexus 工作在 client 和外部 npm 之间，并通过 group repository 合并 npm 仓库以及私有仓库，这样就起到了代理转发的作用。</p><p>了解了 npm 私服的原理，我们就不畏惧任何“雷区”。这部分我也总结了两个社区上常见的问题。</p><h3 id="_4-5-npm-配置作用优先级"><a class="header-anchor" href="#_4-5-npm-配置作用优先级">#</a> 4.5 npm 配置作用优先级</h3><p>npm 可以通过默认配置帮助我们预设好 npm 对项目的影响动作，但是 npm 的配置优先级需要开发者确认了解。</p><p>如下图所示，优先级从左到右依次降低。我们在使用 npm 时需要了解 npm 的设置作用域，排除干扰范围，以免一顿骚操作之后，并没有找到相应的起作用配置。</p><p><img src="/assets/img/CgqCHl_TbZCAanocAADUyWa5fV4429.1acc4e41.png" alt="img"></p><h3 id="_4-6-npm-镜像和安装问题"><a class="header-anchor" href="#_4-6-npm-镜像和安装问题">#</a> 4.6 npm 镜像和安装问题</h3><p>另外一个常见的问题就是 npm 镜像和依赖安装，关于 npm 镜像和依赖安装问题，归根到底还是网络环境导致的，建议有条件的情况下还是<strong>从网络层面解决问题</strong>。</p><p>如果没有条件，也不要紧，办法总比困难多，可以通过设置安装源镜像来解决，这就需要紧跟社区方案，刨根究底了。这里推荐一篇文章：<a href="https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ" target="_blank" rel="noopener noreferrer">聊聊 npm 镜像那些险象环生的坑<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>，文章中有更详细的内容，你可以看看。</p><h2 id="_5-结语"><a class="header-anchor" href="#_5-结语">#</a> 5. 结语</h2><p>关于 npm 的核心理念及安装机制，我们暂且分析到这里。这一讲，我们梳理了 npm 安装逻辑，在了解其安装原理的基础上，对 npm 一些常见使用误区以及使用技巧进行了分析；另外我们也具体了解了 npm 多源镜像和企业级部署私服原理。</p><p><img src="/assets/img/CgpVE1_XAHWAOTwZAAa8HJHvldA513.3baab060.png" alt="img"></p><p>各种环节并不复杂，但是却往往被开发者忽略，导致项目中开发受阻或者架构混乱。本课时，我们也深入多处源码内容，希望对你设计一个完整的工程流程机制有所启发。这里我也给大家留一个思考题：cnpm 是什么，它有什么意义？欢迎你在留言区分享你的观点。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">7/2/2021, 5:45:28 PM</span></div><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/source/basis/Yarn%20%E7%9A%84%E5%AE%89%E8%A3%85%E7%90%86%E5%BF%B5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%9B%B0%E5%A2%83.html" class="nav-link" aria-label="Yarn 的安装理念及如何破解依赖管理困境"><!--[--><!--]--> Yarn 的安装理念及如何破解依赖管理困境 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.89d2221a.js" defer></script><script src="/assets/js/640.35c7ecf5.js" defer></script><script src="/assets/js/app.983a575d.js" defer></script>
  </body>
</html>
