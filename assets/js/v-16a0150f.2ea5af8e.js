(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[822],{8455:(n,a,s)=>{"use strict";s.r(a),s.d(a,{data:()=>t});const t={key:"v-16a0150f",path:"/guide/vue/diff%E7%AE%97%E6%B3%95.html",title:"Diff 算法",lang:"en-US",frontmatter:{title:"Diff 算法"},excerpt:"",headers:[{level:2,title:"key 的意义",slug:"key-的意义",children:[]},{level:2,title:"时间复杂度",slug:"时间复杂度",children:[]},{level:2,title:"1. Snabbdom diff 算法",slug:"_1-snabbdom-diff-算法",children:[{level:3,title:"特点：",slug:"特点",children:[]},{level:3,title:"流程：",slug:"流程",children:[]}]}],filePathRelative:"guide/vue/diff算法.md",git:{updatedTime:1625131972e3,contributors:[]}}},5981:(n,a,s)=>{"use strict";s.r(a),s.d(a,{default:()=>e});const t=(0,s(6252).uE)('<h2 id="key-的意义"><a class="header-anchor" href="#key-的意义">#</a> key 的意义</h2><p>在diff 算法中比较vnode是否是相同节点，如果不设置 key 会最大程度的重用当前 dom 元素，重用 dom 元素有时会有问题，尤其是表单元素。</p><p><strong>key</strong> 的特殊 attribute 主要用在 vue 的虚拟 DOM 算法，在新旧 node 对比的便是 Vnodes。如果不使用 key , Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><p>具有相同父元素的子元素设置唯一的 key，否则可能造成渲染错误</p><p>最常见的用例是结合 <code>v-for</code></p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in items<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>它也可以用于强制替换元素/组件而不是重复使用它，当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code>总是会被替换而不是被修改，因此会触发过渡。</p><h2 id="时间复杂度"><a class="header-anchor" href="#时间复杂度">#</a> 时间复杂度</h2><ul><li><p>O(1) ： 一次</p></li><li><p>O(n) ：循环一次</p></li><li><p>O(n^3) ： 指数级，递归</p></li></ul><h2 id="_1-snabbdom-diff-算法"><a class="header-anchor" href="#_1-snabbdom-diff-算法">#</a> 1. Snabbdom diff 算法</h2><p>diff 算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 <strong>O(n)</strong></p><h3 id="特点"><a class="header-anchor" href="#特点">#</a> 特点：</h3><ol><li>比较只会在同层级进行，不会跨层级比较</li><li>在 diff 比较的过程中，循环从两边向中间收拢</li></ol><h3 id="流程"><a class="header-anchor" href="#流程">#</a> 流程：</h3><ol><li><p>首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引</p></li><li><p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置</p><p><strong>while 循环中会遇到四种情况</strong>：</p><ul><li>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老Vnode 节点的开始索引都加 1</li><li>情形二：当新老 Vnode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老Vnode 节点的结束索引都加 1</li><li>情形三：当老VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老Vnode 节点的开始索引加 1，新 VNode 节点的结束索引减 1</li><li>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。</li></ul></li><li><p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置</p><ul><li>情形一：如果在循环中，oldStartIdx 大于 oldEndIdx 了，那就表示 oldChildren 比 newChildren 先循环完毕，那么 newChildren 里面剩余的节点都是需要新增的节点，把 【newStartIdx, newEndIdx】之间的所有节点都插入到 DOM 中</li><li>情形二：如果在循环中，newStartIdx 大于 newEndIdx 了，那就表示 newChildren 比 oldChildren 先循环完毕，那么 oldChildren 里面剩余的节点都是需要删除的节点，把【oldStartIdx, oldEndIdx】之间的所有节点都删除</li></ul></li></ol>',18),e={render:function(n,a){return t}}}}]);